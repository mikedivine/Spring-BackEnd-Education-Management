package com.cst438.controller;

import com.cst438.domain.*;
import com.cst438.dto.*;
import org.springframework.http.HttpStatus;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.bind.annotation.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;


import java.sql.Date;
import java.util.ArrayList;
import java.util.List;

@RestController
@CrossOrigin(origins = "http://localhost:3000")
public class AssignmentController {

    @Autowired
    AssignmentRepository assignmentRepository;

    @Autowired
    UserRepository userRepository;

    @Autowired
    EnrollmentRepository enrollmentRepository;

    @Autowired
    GradeRepository gradeRepository;

    @Autowired
    CourseRepository courseRepository;

    @Autowired
    SectionRepository sectionRepository;

    /****************************
     LIST ASSIGNMENTS
     ****************************/
    // instructor lists assignments for a section.  Assignments ordered by due date.
    // logged in user must be the instructor for the section
    @GetMapping("/sections/{secNo}/assignments")
    public List<AssignmentDTO> getAssignments(
      @PathVariable("secNo") int secNo,
      @RequestParam("instructorEmail") String instructorEmail
      ) {
        Section s = sectionRepository.findBySectionNo(secNo);
        if (s == null) {
          throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Section "
              + secNo + " not found ");
        }
        // Verify user exists and is an instructor and is the correct instructor
        verifyInstructor(instructorEmail, s.getInstructorEmail());

        // hint: use the assignment repository method
        //  findBySectionNoOrderByDueDate to return
        //  a list of assignments
        List<Assignment> assignments = assignmentRepository.findBySectionNoOrderByDueDate(secNo);
        List<AssignmentDTO> dto_list = new ArrayList<>();
        for(Assignment a : assignments) {
            Section section = a.getSection();
            Course course = section.getCourse();
            dto_list.add(
                    new AssignmentDTO(
                            a.getAssignmentId(),
                            a.getTitle(),
                            a.getDue_date().toString(),
                            course.getCourseId(),
                            course.getTitle(),
                            section.getSecId(),
                            section.getSectionNo()
                    ));
        }
        return dto_list;
    }

    /****************************
     ADD ASSIGNMENT
     ****************************/
    // add assignment
    // user must be instructor of the section
    // return AssignmentDTO with assignmentID generated by database
    @PostMapping("/assignments")
    public AssignmentDTO createAssignment(
      @RequestBody AssignmentDTO assignmentDTO,
      @RequestParam("instructorEmail") String instructorEmail
      ) {

        Assignment a = new Assignment();
        a.setTitle(assignmentDTO.title());
        a.setDue_date(Date.valueOf(assignmentDTO.dueDate()));

        //check if the course exists
        Course c = courseRepository.findById(assignmentDTO.courseId()).
          orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
              "Course not found " + assignmentDTO.id()));

        //check if the section exists
        Section s = sectionRepository.findById(assignmentDTO.secNo()).
          orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
            "Section " + assignmentDTO.secNo() + " not found."));

        //link the assignment to the section
        a.setSection(s);

        // Verify user exists and is an instructor and is the correct instructor
        verifyInstructor(instructorEmail, s.getInstructorEmail());

        // check that the DueDate is after StartDate and before EndDate for the section
        Term term = s.getTerm();
        if (a.getDue_date().before(term.getStartDate())) {
          throw new ResponseStatusException(HttpStatus.CONFLICT,
            "You have attempted to add an assignment with the Due Date: " + a.getDue_date() + " before the Section Start Date " + term.getStartDate());
        } else if (a.getDue_date().after(term.getEndDate())) {
          throw new ResponseStatusException(HttpStatus.CONFLICT,
            "You have attempted to add an assignment with the Due Date: " + a.getDue_date() + " after the Section End Date: " + term.getEndDate());
        }

        //save Assignment ID, Title, DueDate, and Section to Assignment Table.
        assignmentRepository.save(a);

        //return the information
        return new AssignmentDTO(
            a.getAssignmentId(),
            a.getTitle(),
            assignmentDTO.dueDate(),
            c.getCourseId(),
            c.getTitle(),
            s.getSecId(),
            s.getSectionNo()
        );
    }

    /****************************
     UPDATE ASSIGNMENT
     ****************************/
    // update assignment for a section.  Only title and dueDate may be changed.
    // user must be instructor of the section
    // return updated AssignmentDTO
    @PutMapping("/assignments")
    public AssignmentDTO updateAssignment(
      @RequestBody AssignmentDTO dto,
      @RequestParam("instructorEmail") String instructorEmail
      ) {

        Assignment a = assignmentRepository.findById(dto.id()).
          orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
          "Assignment not found"));

        Section s = a.getSection();
        Course c = s.getCourse();
        // Verify user exists and is an instructor and is the correct instructor
        verifyInstructor(instructorEmail, s.getInstructorEmail());

        a.setTitle(dto.title());
        a.setDue_date(Date.valueOf(dto.dueDate()));
        assignmentRepository.save(a);
        return new AssignmentDTO(
            a.getAssignmentId(),
            a.getTitle(),
            a.getDue_date().toString(),
            c.getCourseId(),
            c.getTitle(),
            a.getSection().getSecId(),
            a.getSection().getSectionNo()
        );

    }

    /****************************
      DELETE ASSIGNMENT
     ****************************/
    // delete assignment for a section
    // logged in user must be instructor of the section
    @DeleteMapping("/assignments/{assignmentId}")
    public void deleteAssignment(
      @PathVariable("assignmentId") int assignmentId,
      @RequestParam("instructorEmail") String instructorEmail
      ) {

        Assignment a = assignmentRepository.findById(assignmentId).
          orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
            "Assignment not found"));
        Section s = a.getSection();

        // Verify user exists and is an instructor and is the correct instructor
        verifyInstructor(instructorEmail, s.getInstructorEmail());
        List<Grade> grades = gradeRepository.findByAssignmentId(assignmentId);
        gradeRepository.deleteAll(grades);
        assignmentRepository.delete(a);

    }

    /****************************
     LIST GRADES FOR ASSIGNMENT
     ****************************/
    // instructor gets grades for assignment ordered by student name
    // user must be instructor for the section
    @GetMapping("/assignments/{assignmentId}/grades")
    public List<GradeDTO> getAssignmentGrades(
      @PathVariable("assignmentId") int assignmentId,
      @RequestParam("instructorEmail") String instructorEmail
      ) {

      // Finds the assignment by ID to get its related sectionNo
        Assignment assignment = assignmentRepository.findById(assignmentId)
          .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND,
            "Assignment " + assignmentId + " not found"));

        Section s = assignment.getSection();

        // Verify user exists and is an instructor and is the correct instructor
        verifyInstructor(instructorEmail, s.getInstructorEmail());

        // Gets all enrollments found under the sections related to the assignment id
        List<Enrollment> enrollments = enrollmentRepository.findEnrollmentsBySectionNoOrderByStudentName(
          assignment.getSection().getSectionNo());

        if (enrollments == null) {
          throw new ResponseStatusException(HttpStatus.NOT_FOUND,
            "No enrollments found.");
        }

        List<GradeDTO> gradeDTOs = new ArrayList<>();

        for (Enrollment enrollment : enrollments) {
          // Finds the assignment grade related to the assignmentID and enrollmentID
          Grade grade = gradeRepository.findByEnrollmentIdAndAssignmentId(
            enrollment.getEnrollmentId(), assignmentId); // Create a new grade if it doesn't exist

            if (!(grade == null)) {
                gradeDTOs.add(new GradeDTO(grade.getGradeId(),
                enrollment.getUser().getName(),
                enrollment.getUser().getEmail(),
                grade.getAssignment().getTitle(),
                enrollment.getSection().getCourse().getCourseId(),
                enrollment.getSection().getSecId(),
                grade.getScore()));
            }
        }
        if (gradeDTOs.isEmpty()) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND,
              "No Grades found.");
        }
        return gradeDTOs;
    }

    /****************************
     UPLOAD GRADES FOR ASSIGNMENT
     ****************************/
    // instructor uploads grades for assignment
    // user must be instructor for the section
    @Transactional
    @PutMapping("/grades")
    public List<GradeDTO> updateGrades(
      @RequestBody List<GradeDTO> dlist,
      @RequestParam("instructorEmail") String instructorEmail
      ) {

        for (GradeDTO gradeDTO : dlist) {
          // Retrieve the Grade entity from the DB using the ID from the DTO provided
          Grade grade = gradeRepository.findById(gradeDTO.gradeId())
            .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Grade not found"));

          Enrollment e = grade.getEnrollment();
          Section s = e.getSection();

          // Verify user exists and is an instructor and is the correct instructor
          verifyInstructor(instructorEmail, s.getInstructorEmail());

          // Updates the score of the Grade
          grade.setScore(gradeDTO.score());

          // Saves the updated Grade in the DB
          gradeRepository.save(grade);
        }
        return dlist;

    }

    /****************************
     STUDENT LISTS ASSIGNMENTS
     ****************************/
    // student lists their assignments/grades for an enrollment ordered by due date
    // student must be enrolled in the section
    @GetMapping("/assignments")
    public List<AssignmentStudentDTO> getStudentAssignments(
            @RequestParam("studentId") int studentId,
            @RequestParam("year") int year,
            @RequestParam("semester") String semester) {

        //creates a list of sections based on studentId, year, semester
        List<Section> sections = sectionRepository.findByStudentIdAndYearAndSemester(studentId, year, semester);
        List<AssignmentStudentDTO> assignmentDTO = new ArrayList<>();

        //creates a list assignments for the sections above
        for (Section section : sections){
            List<Assignment> assignments = assignmentRepository.findBySectionNoOrderByDueDate(section.getSectionNo());

            //creates a list of AssignmentStudentDTO's based on the list of assignments above
            for(Assignment assignment : assignments){
                Course course = section.getCourse();
              Enrollment enrollment = enrollmentRepository.findEnrollmentBySectionNoAndStudentId(
                section.getSectionNo(), studentId);
              Grade grade = gradeRepository.findByEnrollmentIdAndAssignmentId(
                enrollment.getEnrollmentId(), assignment.getAssignmentId());
              Integer score = -1;

              if (grade != null) {
                score = grade.getScore();
              }

              assignmentDTO.add(
                new AssignmentStudentDTO(
                  assignment.getAssignmentId(),
                  assignment.getTitle(),
                  assignment.getDue_date(),
                  course.getCourseId(),
                  course.getTitle(),
                  assignment.getSection().getSecId(),
                  score
                ));
            }
        }
        return assignmentDTO;
    }

    private void verifyInstructor(String email, String instructorEmail) {
        // Verify user exists and is a student
        User user = userRepository.findByEmail(email);
        if (user == null) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found.");
        }
        if (!(user.getType().equals("INSTRUCTOR"))) {
            throw new ResponseStatusException(HttpStatus.CONFLICT,
              "You are not an Instructor.");
        }
        if (!(email.equals(instructorEmail))) {
            throw new ResponseStatusException(HttpStatus.CONFLICT,
              "You are not the Instructor of the Section.");
        }
    }
}